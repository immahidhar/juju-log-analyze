from collections import defaultdict
from typing import Optional
import argparse
import logging
import re

"""
This program will read a log file generated by juju and analyze it
"""


class JujuUtil:
    """
    A utility class to help with analyzing juju logs
    """

    SEVERITY_LEVELS = {'INFO', 'DEBUG', 'WARNING', 'ERROR'}

    @staticmethod
    def log_line_starts_with_juju_unit(log: str) -> bool:
        """
        check if the log line starts with a juju "unit"
        :return: True if it is else False
        """
        if len(log) > 4:
            return log[:4].lower() == 'unit'
        return False

    @staticmethod
    def get_charm_from_unit(unit_name: str) -> Optional[str]:
        """
        get target_charm name from unit name
        :param unit_name
        :return: target_charm name if regex matches expected, '' if not
        """
        match = re.match(r'unit-(.*?)-\d+', unit_name)
        if match:
            return match.group(1)
        return None

    @staticmethod
    def get_severities_frequency_map() -> dict:
        severities = defaultdict(lambda:0)
        for severity in JujuUtil.SEVERITY_LEVELS:
            severities[severity] = 0
        return severities

    @staticmethod
    def get_severities_map_with_set_val() -> dict:
        severities = defaultdict(set)
        for severity in JujuUtil.SEVERITY_LEVELS:
            severities[severity] = set()
        return severities

class JujuLogAnalyzer:
    """
    Juju Log Analyze class that contains logic to analyze juju specific log files
    """

    def __init__(self, log_file: str, charm: str = ''):
        self.log_file = log_file
        self.target_charm = charm
        self.charms_analyzed = defaultdict(lambda:JujuUtil.get_severities_frequency_map())
        """
        charms_analyzed { charm :
                              { severity : count
                                .
                                .
                                .
                              }
                         .
                         .
                         .
                        }
        """
        self.severities_map_with_log_set_val = JujuUtil.get_severities_map_with_set_val()
        """
        severities_map_with_log_set_val { severity: set()
                                      .
                                      .
                                      .
                                    }
        """
        self.duplicate_logs = JujuUtil.get_severities_frequency_map()
        """
        duplicate_logs { severity: count
                         .
                         .
                         .
                        }
        """
        self.total_lines = 0
        logging.info(f'Juju Log Analyzer initialized')

    def analyze_juju_unit_logs(self) -> None:
        """
        read log file and return only lines that contain "unit" related logs and analyze each one
        :return:
        """
        logging.info(f'reading log file {self.log_file}')
        with open(self.log_file) as fp:
            # read log file line by line
            for log in fp:
                if log:
                    self.total_lines += 1
                    # check iff line starts with juju unit name
                    log_splits = log.split()
                    if len(log_splits) > 2: # at least should have [unit, timestamp, LEVEL, ... ]
                        if JujuUtil.log_line_starts_with_juju_unit(log_splits[0]):
                            charm_name = JujuUtil.get_charm_from_unit(log_splits[0])
                            if charm_name:
                                logging.debug(f'{charm_name}, {log_splits[1]}, {log_splits[2]}, {log_splits[3:]}')
                                # check for optional target_charm argument
                                if self.target_charm and self.target_charm.lower() != charm_name.lower():
                                    continue
                                self.__perform_charm_analysis(charm_name, log_splits)
        logging.info(f'analysis done')
        return

    def __perform_charm_analysis(self, charm_name, log_splits) -> None:
        """
        analyze the log line
        :param charm_name:
        :param log_splits:
        :return:
        """

        # charm and severity analysis
        severity = log_splits[2]
        self.charms_analyzed[charm_name][severity] += 1

        # duplicate message analysis
        msg = ''
        for i in range(3, len(log_splits)):
            msg += log_splits[i]
        if msg.lower() in self.severities_map_with_log_set_val[severity]:
            # duplicate
            self.duplicate_logs[severity] += 1
        else:
            # remember this message
            self.severities_map_with_log_set_val[severity].add(msg.lower())

        return

    def produce_analysis(self) -> None:
        """
        Produce required analysis and print them to stdout
        :return:
        """

        # sanity check
        if not self.__charms_found():
            return

        # 1. The charms that produced warning messages (if not restricted to a single target_charm)
        self.print_charms_with_severity('WARNING')
        self.print_charms_with_severity('ERROR')
        # 2. The number of each severity of message.
        self.print_number_of_each_severity()
        # 3. The number of duplicate messages (and their severity).
        self.print_number_of_duplicate_message()
        # 4. The proportions of each type of log message for each target_charm (or just the single target_charm).
        self.print_proportions_of_each_type_per_charm()
        # 5. The total number of log messages per charm.
        self.print_number_of_messages_per_charm()
        # 6. The total number of log messages.
        self.print_total_number_of_logs()

        print()

    def __charms_found(self) -> bool:
        """
        sanity check if any charms are analyzed and found or not
        :return: True if any charm is analyzed, False if not
        """
        if len(self.charms_analyzed) == 0:
            if self.target_charm:
                print(f'No charms with name {self.target_charm} found!')
            else:
                print(f'No charms found!')
            return False
        else:
            print(f'\nCharms analyzed:\n{list(self.charms_analyzed.keys())}')
            print(f'All other log statements are ignored!')
            return True

    def print_charms_with_severity(self, severity) -> None:
        """
        1. Print charms that produced warning messages (if not restricted to a single target_charm)
        :param severity:
        :return:
        """
        charms = set()
        for charm in self.charms_analyzed:
            if self.charms_analyzed[charm][severity] > 0:
                charms.add(charm)
        print(f'\nThe charms that produced {severity}s:\n{charms if len(charms) > 0 else None}')

    def print_number_of_each_severity(self) -> None:
        """
        2. Print number of each severity of message.
        :return:
        """
        severities = JujuUtil.get_severities_frequency_map()
        for charm in self.charms_analyzed:
            for sev in self.charms_analyzed[charm]:
                severities[sev] += self.charms_analyzed[charm][sev]
        print(f'\nThe number of each severity of message:')
        for sev in severities:
            print(f'\t{sev} : {severities[sev]}')

    def print_number_of_duplicate_message(self) -> None:
        """
        3. Print number of duplicate messages (and their severity).
        :return:
        """
        print(f'\nThe number of duplicate messages per severity:')
        for sev in self.duplicate_logs:
            print(f'\t{sev} : {self.duplicate_logs[sev]}')

    def print_proportions_of_each_type_per_charm(self) -> None:
        """
        4. Print the proportions of each type of log message for each target_charm (or just the single target_charm).
        :return:
        """
        print(f'\nThe proportions of each type of log message for each charm:')
        for charm in self.charms_analyzed:
            count = 0
            print(f'{charm}:')
            for sev in self.charms_analyzed[charm]:
                count += self.charms_analyzed[charm][sev]
            for sev in self.charms_analyzed[charm]:
                print(f'\t{sev} : {(self.charms_analyzed[charm][sev] / count) * 100} %')

    def print_number_of_messages_per_charm(self) -> None:
        """
        5. Print total number of log messages per charm.
        :return:
        """
        print(f'\nThe total number of log messages per charm:')
        for charm in self.charms_analyzed:
            count = 0
            for sev in self.charms_analyzed[charm]:
                count += self.charms_analyzed[charm][sev]
            print(f'\t{charm} : {count}')

    def print_total_number_of_logs(self) -> None:
        """
        6. Print total number of log messages.
        :return:
        """
        count = 0
        for charm in self.charms_analyzed:
            for sev in self.charms_analyzed[charm]:
                count += self.charms_analyzed[charm][sev]
        print(f'\nThe total number of log messages analyzed : {count}')
        print(f'\nThe total number of lines in log file : {self.total_lines}')


def parse_arguments() -> argparse.Namespace:
    """
    validate command line arguments and parse them
    :return: namespace with arguments
    """
    parser = argparse.ArgumentParser("python3 juju-log-analyze.py")
    parser.add_argument("juju_log_file", help=" file path of juju log", type=str)
    parser.add_argument("target_charm", nargs='?', help=" target_charm", type=str, default='')
    namespace = parser.parse_args()
    logging.info(namespace)
    return namespace

def main():
    """
    main function -> entry point
    :return:
    """
    # basic logging
    logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

    # parse command line arguments
    args = parse_arguments()

    # initialize juju log analyzer
    juju_log_analyzer = JujuLogAnalyzer(args.juju_log_file, args.target_charm)
    # perform analysis
    juju_log_analyzer.analyze_juju_unit_logs()
    # print output
    juju_log_analyzer.produce_analysis()


if __name__ == '__main__':
    main()